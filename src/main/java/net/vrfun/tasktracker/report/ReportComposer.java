/*
 * Copyright (c) 2020-2021 by Botorabi. All rights reserved.
 * https://github.com/botorabi/TaskTracker
 *
 * License: MIT License (MIT), read the LICENSE text in
 *          main directory for more details.
 */
package net.vrfun.tasktracker.report;

import net.vrfun.tasktracker.report.docgen.*;
import net.vrfun.tasktracker.task.*;
import net.vrfun.tasktracker.user.Team;
import net.vrfun.tasktracker.user.TeamRepository;
import org.apache.commons.lang.StringUtils;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.lang.NonNull;
import org.springframework.lang.Nullable;
import org.springframework.stereotype.Service;

import java.io.ByteArrayOutputStream;
import java.time.LocalDate;
import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;
import java.util.List;


/**
 * Report document composer
 *
 * @author          boto
 * Creation Date    September 2020
 */
@Service
public class ReportComposer {

    private final Logger LOGGER = LoggerFactory.getLogger(this.getClass());

    @Value("${app.name}")
    private String appName;

    @Value("${app.version}")
    private String appVersion;

    @Value("${company.name: ''}")
    private String companyName;

    public final static String REPORT_DATE_FORMAT = "d. MMMM yyyy";

    private final ProgressRepository progressRepository;
    private final TeamRepository teamRepository;
    private final TaskRepository taskRepository;


    @Autowired
    public ReportComposer(@NonNull final ProgressRepository progressRepository,
                          @NonNull final TeamRepository teamRepository,
                          @NonNull final TaskRepository taskRepository) {

        this.progressRepository = progressRepository;
        this.teamRepository = teamRepository;
        this.taskRepository = taskRepository;
    }

    @NonNull
    public ByteArrayOutputStream createTeamReport(@NonNull final List<Long> teamIDs,
                                                  @NonNull final LocalDate fromDate,
                                                  @NonNull final LocalDate toDate,
                                                  @NonNull final ReportFormat reportFormat,
                                                  @NonNull final String title,
                                                  @NonNull final String subTitle,
                                                  @NonNull final String language) {

        List<Team> teamList = teamRepository.findAllById(teamIDs);
        if (teamList.isEmpty()) {
            throw new IllegalArgumentException("Invalid team IDs!");
        }

        ReportGenerator reportGenerator = ReportGeneratorFactory.build(reportFormat);
        ReportI18n reportI18n = loadLocalization(language);
        reportGenerator.setLocale(reportI18n);
        try {
            String footer = companyName + ", Generated by " + appName + " v" + appVersion;

            reportGenerator.begin();
            reportGenerator.setFooter(footer);
            reportGenerator.generateCoverPage(title, subTitle +
                    "\n" + reportI18n.translate("period") + ": " + fromDate.format(DateTimeFormatter.ofPattern(REPORT_DATE_FORMAT)) + " - " +
                    toDate.format(DateTimeFormatter.ofPattern(REPORT_DATE_FORMAT)) +
                    "\n" + reportI18n.translate("created") + ": " + LocalDateTime.now().format(DateTimeFormatter.ofPattern(REPORT_DATE_FORMAT + " / HH:mm")));

            teamList.forEach((team -> {
                LOGGER.debug("Generating progress for team: {}", team.getName());

                reportGenerator.sectionBegin(team.getName());

                taskRepository.findTeamTasks(team).forEach((task -> {
                    LOGGER.debug(" Generating progress for task: {}", task.getTitle());

                    List<Progress> progressList = progressRepository.findByTaskIdAndReportWeekBetween(task.getId(), fromDate, toDate);

                    reportGenerator.sectionAppend(progressList);
                }));

                reportGenerator.sectionEnd();
            }));

            return reportGenerator.end();

        } catch (Throwable throwable) {
            LOGGER.error("Could not create report file, reason: {}", throwable.getMessage());
            throw throwable;
        }
    }

    @Nullable
    protected ReportI18n loadLocalization(@NonNull final String language) {
        ReportI18n.Locale locale;
        if (StringUtils.isEmpty(language) || language.equalsIgnoreCase("en")) {
            locale = ReportI18n.Locale.EN;
        }
        else if (language.equalsIgnoreCase("de")) {
            locale = ReportI18n.Locale.DE;
        }
        else {
            throw new IllegalArgumentException("Unsupported language: " + language);
        }

        try {
            return ReportI18n.build(locale);
        } catch (Exception exception) {
            throw new IllegalArgumentException("Could not setup the locale, reason: " + exception.getMessage());
        }
    }
}
